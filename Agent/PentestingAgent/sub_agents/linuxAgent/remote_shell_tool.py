import requests
import json
import time
from typing import List, Dict, Any, Optional
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def execute_remote_commands(
    commands: List[str],
    host: str = "localhost",
    port: int = 3000,
    endpoint: str = "/execute",
    timeout: int = 30
) -> Dict[str, Any]:
    """
    Execute a list of commands via HTTP POST requests to the remote shell server.
    Matches the format expected by index.js - sends commands array to /execute endpoint.
    
    Args:
        commands (List[str]): List of commands to execute
        host (str): Remote host address (default: localhost)
        port (int): HTTP port (default: 3000)
        endpoint (str): API endpoint (default: /execute)
        timeout (int): Request timeout in seconds (default: 30)
    
    Returns:
        Dict[str, Any]: Dictionary containing execution results with the following structure:
        {
            "success": bool,
            "results": List[Dict[str, Any]],
            "error": Optional[str],
            "total_commands": int,
            "successful_commands": int,
            "failed_commands": int
        }
    """
    
    results = {
        "success": False,
        "results": [],
        "error": None,
        "total_commands": len(commands),
        "successful_commands": 0,
        "failed_commands": 0
    }
    
    # Construct the base URL
    base_url = f"http://{host}:{port}{endpoint}"
    
    try:
        logger.info(f"Connecting to remote shell server at {base_url}")
        logger.info(f"Executing commands: {commands}")
        
        # Prepare the POST request payload matching index.js format
        payload = {
            "commands": commands
        }
        
        headers = {
            "Content-Type": "application/json"
        }
        
        # Make the POST request
        response = requests.post(
            base_url,
            json=payload,
            headers=headers,
            timeout=timeout
        )
        
        # Check if request was successful
        if response.status_code == 200:
            try:
                # Parse the response
                response_data = response.json()
                logger.info(f"Received response: {response_data}")
                
                # Handle different response formats
                if isinstance(response_data, list):
                    # If response is a list of results
                    for i, cmd_result in enumerate(response_data):
                        command_result = {
                            "command": commands[i] if i < len(commands) else f"command_{i}",
                            "command_index": i,
                            "success": cmd_result.get("success", True),
                            "stdout": cmd_result.get("stdout", ""),
                            "stderr": cmd_result.get("stderr", ""),
                            "exit_code": cmd_result.get("exit_code", 0),
                            "execution_time": cmd_result.get("execution_time", 0)
                        }
                        results["results"].append(command_result)
                        
                        if command_result["success"]:
                            results["successful_commands"] += 1
                        else:
                            results["failed_commands"] += 1
                            
                elif isinstance(response_data, dict):
                    # If response is a dictionary with results array
                    if "results" in response_data:
                        for i, cmd_result in enumerate(response_data["results"]):
                            command_result = {
                                "command": commands[i] if i < len(commands) else f"command_{i}",
                                "command_index": i,
                                "success": cmd_result.get("success", True),
                                "stdout": cmd_result.get("stdout", ""),
                                "stderr": cmd_result.get("stderr", ""),
                                "exit_code": cmd_result.get("exit_code", 0),
                                "execution_time": cmd_result.get("execution_time", 0)
                            }
                            results["results"].append(command_result)
                            
                            if command_result["success"]:
                                results["successful_commands"] += 1
                            else:
                                results["failed_commands"] += 1
                    else:
                        # Single result format
                        command_result = {
                            "command": commands[0] if commands else "unknown",
                            "command_index": 0,
                            "success": response_data.get("success", True),
                            "stdout": response_data.get("stdout", ""),
                            "stderr": response_data.get("stderr", ""),
                            "exit_code": response_data.get("exit_code", 0),
                            "execution_time": response_data.get("execution_time", 0)
                        }
                        results["results"].append(command_result)
                        
                        if command_result["success"]:
                            results["successful_commands"] += 1
                        else:
                            results["failed_commands"] += 1
                else:
                    # If response is plain text, treat as stdout
                    command_result = {
                        "command": commands[0] if commands else "unknown",
                        "command_index": 0,
                        "success": True,
                        "stdout": str(response_data),
                        "stderr": "",
                        "exit_code": 0,
                        "execution_time": 0
                    }
                    results["results"].append(command_result)
                    results["successful_commands"] += 1
                    
            except json.JSONDecodeError as e:
                # If response is not JSON, treat it as stdout for all commands
                logger.warning(f"Non-JSON response received: {response.text}")
                for i, command in enumerate(commands):
                    command_result = {
                        "command": command,
                        "command_index": i,
                        "success": True,
                        "stdout": response.text,
                        "stderr": "",
                        "exit_code": 0,
                        "execution_time": 0
                    }
                    results["results"].append(command_result)
                    results["successful_commands"] += 1
                    
        else:
            # HTTP error
            results["failed_commands"] = len(commands)
            for i, command in enumerate(commands):
                command_result = {
                    "command": command,
                    "command_index": i,
                    "success": False,
                    "stdout": "",
                    "stderr": f"HTTP {response.status_code}: {response.text}",
                    "exit_code": response.status_code,
                    "execution_time": 0
                }
                results["results"].append(command_result)
            logger.error(f"HTTP error {response.status_code} for commands")
        
        # Overall success if at least one command succeeded
        results["success"] = results["successful_commands"] > 0
        
    except requests.exceptions.Timeout:
        results["error"] = f"Request timeout after {timeout} seconds"
        results["failed_commands"] = len(commands)
        for i, command in enumerate(commands):
            command_result = {
                "command": command,
                "command_index": i,
                "success": False,
                "stdout": "",
                "stderr": f"Request timeout after {timeout} seconds",
                "exit_code": -1,
                "execution_time": timeout
            }
            results["results"].append(command_result)
        logger.error("Request timeout")
        
    except requests.exceptions.ConnectionError:
        results["error"] = f"Connection error: Could not connect to {base_url}"
        results["failed_commands"] = len(commands)
        for i, command in enumerate(commands):
            command_result = {
                "command": command,
                "command_index": i,
                "success": False,
                "stdout": "",
                "stderr": f"Connection error: Could not connect to {base_url}",
                "exit_code": -1,
                "execution_time": 0
            }
            results["results"].append(command_result)
        logger.error("Connection error")
        
    except Exception as e:
        results["error"] = str(e)
        results["failed_commands"] = len(commands)
        for i, command in enumerate(commands):
            command_result = {
                "command": command,
                "command_index": i,
                "success": False,
                "stdout": "",
                "stderr": str(e),
                "exit_code": -1,
                "execution_time": 0
            }
            results["results"].append(command_result)
        logger.error(f"General error: {str(e)}")
    
    return results

def execute_single_remote_command(
    command: str,
    host: str = "localhost",
    port: int = 3000,
    endpoint: str = "/execute",
    timeout: int = 30
) -> Dict[str, Any]:
    """
    Execute a single command via HTTP POST request to the remote shell server.
    Matches the format expected by index.js.
    
    Args:
        command (str): Command to execute
        host (str): Remote host address (default: localhost)
        port (int): HTTP port (default: 3000)
        endpoint (str): API endpoint (default: /execute)
        timeout (int): Request timeout in seconds (default: 30)
    
    Returns:
        Dict[str, Any]: Dictionary containing execution result
    """
    return execute_remote_commands(
        commands=[command],
        host=host,
        port=port,
        endpoint=endpoint,
        timeout=timeout
    )

def check_server_status(
    host: str = "localhost",
    port: int = 3000,
    endpoint: str = "/health",
    timeout: int = 10
) -> Dict[str, Any]:
    """
    Check if the remote shell server is running and accessible.
    
    Args:
        host (str): Remote host address (default: localhost)
        port (int): HTTP port (default: 3000)
        endpoint (str): Health check endpoint (default: /health)
        timeout (int): Request timeout in seconds (default: 10)
    
    Returns:
        Dict[str, Any]: Server status information
    """
    try:
        url = f"http://{host}:{port}{endpoint}"
        response = requests.get(url, timeout=timeout)
        
        if response.status_code == 200:
            return {
                "status": "running",
                "message": "Server is running and accessible",
                "url": url,
                "response": response.json() if response.headers.get('content-type', '').startswith('application/json') else response.text
            }
        else:
            return {
                "status": "error",
                "message": f"Server responded with status code {response.status_code}",
                "url": url,
                "response": response.text
            }
            
    except requests.exceptions.ConnectionError:
        return {
            "status": "unreachable",
            "message": f"Could not connect to server at {url}",
            "url": url,
            "response": None
        }
    except requests.exceptions.Timeout:
        return {
            "status": "timeout",
            "message": f"Request to {url} timed out",
            "url": url,
            "response": None
        }
    except Exception as e:
        return {
            "status": "error",
            "message": str(e),
            "url": url,
            "response": None
        }

# Example usage and testing
if __name__ == "__main__":
    # Example commands to test
    test_commands = [
        "whoami",
        "pwd",
        "ls -la",
        "echo 'Hello from remote shell'",
        "uname -a"
    ]
    
    print("Remote shell tool ready for use!")
    print("This tool makes HTTP POST requests to localhost:3000/execute")
    print("Format: {\"commands\": [\"command1\", \"command2\", ...]}")
    print()
    
    # Check server status
    print("Checking server status...")
    status = check_server_status()
    print(f"Server status: {status['status']}")
    print(f"Message: {status['message']}")
    print()
    
    # Test with a simple command
    print("Testing with a simple command...")
    result = execute_single_remote_command("echo 'test'")
    print(f"Result: {result}")
    
    # Test with multiple commands
    print("\nTesting with multiple commands...")
    result = execute_remote_commands(test_commands)
    print(f"Result: {result}") 